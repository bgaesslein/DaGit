{
    "type": "table",
    "database": null,
    "name": "objects",
    "withoutRowId": false,
    "strict": false,
    "ddl": "CREATE TABLE objects (name text primary key, type text, object jsonb);",
    "columns": [
        {
            "name": "name",
            "type": "text",
            "constraints": [
                {
                    "type": "PRIMARY KEY",
                    "definition": "primary key"
                }
            ]
        },
        {
            "name": "type",
            "type": "text"
        },
        {
            "name": "object",
            "type": "jsonb"
        }
    ],
    "rows": [
        [
            "937cb25dd4d341bf341ecc76c242808f215fa0f6",
            "commit",
            "{\"parents\": null, \"tree\": \"657e8422719f786d7768d7f6512c6b2ff42e4433\"}"
        ],
        [
            "d3146cf1d7abec84ff9cc78996f6cbd114b0d0ff",
            "blob",
            "module github.com\/gogit\n\ngo 1.19\n\nrequire (\n\tgithub.com\/cpuguy83\/go-md2man\/v2 v2.0.2 \/\/ indirect\n\tgithub.com\/mattn\/go-sqlite3 v1.14.22 \/\/ indirect\n\tgithub.com\/mitchellh\/colorstring v0.0.0-20190213212951-d06e56a500db \/\/ indirect\n\tgithub.com\/rivo\/uniseg v0.4.7 \/\/ indirect\n\tgithub.com\/russross\/blackfriday\/v2 v2.1.0 \/\/ indirect\n\tgithub.com\/schollz\/progressbar\/v3 v3.14.2 \/\/ indirect\n\tgithub.com\/urfave\/cli\/v2 v2.27.1 \/\/ indirect\n\tgithub.com\/xrash\/smetrics v0.0.0-20201216005158-039620a65673 \/\/ indirect\n\tgolang.org\/x\/sys v0.17.0 \/\/ indirect\n\tgolang.org\/x\/term v0.17.0 \/\/ indirect\n)\n"
        ],
        [
            "065b862034d6f337dd5e4454df4ca0d1185dac24",
            "tree",
            "[\n{\"mode\": \"100644\", \"name\": \".gitignore\", \"hash\": \"66fd13c903cac02eb9657cd53fb227823484401d\"},\n{\"mode\": \"100644\", \"name\": \"LICENSE\", \"hash\": \"9adcb40f927482119da665a20b8379ab8e161c8a\"},\n{\"mode\": \"100644\", \"name\": \"README.md\", \"hash\": \"5803288b25eb0cfc5fc8648645a43b767290dcdc\"},\n{\"mode\": \"100644\", \"name\": \"go.mod\", \"hash\": \"04cae2c8019c039782fac140c206e93ce0066cca\"},\n{\"mode\": \"100644\", \"name\": \"go.sum\", \"hash\": \"9459eac0626138eb2c9fb5ccc76ced79264f61c0\"},\n{\"mode\": \"100644\", \"name\": \"gogit.go\", \"hash\": \"c88d95727f2f481b6472730b2241eec0c9cb0242\"}\n]\n"
        ],
        [
            "0d9123ee48ee694c8173e3adf917508287a7c94f",
            "commit",
            "{\"parents\": [\"e57559ada48909cb03baf7c3bf0e43b2f40ed13d\"], \"tree\": \"7a895999e1fa52604c4aff0fe04735f1ee9b8b38\"}"
        ],
        [
            "7ae80028cbf58eb4986e75e5ef5f8eb59b9055d4",
            "commit",
            "{\"parents\": [\"be2cddff4775a26ad7441b65fcf2c9ea2cc6d126\"], \"tree\": \"7b68193936a0b4845077bc9c55a29d33305db281\"}"
        ],
        [
            "5803288b25eb0cfc5fc8648645a43b767290dcdc",
            "blob",
            "# GitQL\nGit is a graph. Why not query Git's database using GraphQL.\n"
        ],
        [
            "66c4c43e0134f09c8ae61d4bd30c6bbc47bf386f",
            "tree",
            "[\n{\"mode\": \"100644\", \"name\": \".gitignore\", \"hash\": \"66fd13c903cac02eb9657cd53fb227823484401d\"},\n{\"mode\": \"100644\", \"name\": \"LICENSE\", \"hash\": \"9adcb40f927482119da665a20b8379ab8e161c8a\"},\n{\"mode\": \"100644\", \"name\": \"README.md\", \"hash\": \"5803288b25eb0cfc5fc8648645a43b767290dcdc\"},\n{\"mode\": \"100644\", \"name\": \"git.go\", \"hash\": \"4ace0c14f0ed8026c2df67a1e183988133904d33\"}\n]\n"
        ],
        [
            "00e24b73b0d73017b3e8a9d5fb680cc30e0db122",
            "commit",
            "{\"parents\": [\"0d9123ee48ee694c8173e3adf917508287a7c94f\"], \"tree\": \"065b862034d6f337dd5e4454df4ca0d1185dac24\"}"
        ],
        [
            "2d6d979b7360d8612fb31a44e3f8ba3b9d0a8c3a",
            "blob",
            "package main\n\nimport (\n\t\"bytes\"\n\t\"compress\/zlib\"\n\t\"encoding\/hex\"\n\t\"encoding\/json\"\n\t\"fmt\"\n\t\"io\/fs\"\n\t\"io\/ioutil\"\n\t\"path\/filepath\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nconst (\n\tSPACE byte = 32\n\tNUL   byte = 0\n)\n\ntype Object struct {\n\tobj_type string\n\tsize     string\n\tlocation string\n\tname     string\n\tcontent  []byte\n}\n\n\/\/ Given a byte find the first byte in a data slice that equals the match_byte, returning the index.\n\/\/ If no match is found, returns -1\nfunc findFirstMatch(match_byte byte, start_index int, data *[]byte) int {\n\tfor i, this_byte := range (*data)[start_index:] {\n\t\tif this_byte == match_byte {\n\t\t\treturn start_index + i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc getType(data *[]byte) (string, int) {\n\tfirst_space_index := findFirstMatch(SPACE, 0, data)\n\tobj_type := string((*data)[0:first_space_index])\n\treturn strings.TrimSpace(obj_type), first_space_index\n}\n\n\/\/ second return value is the start of the object's content\nfunc getSize(first_space_index int, data *[]byte) (string, int) {\n\tfirst_nul_index := findFirstMatch(NUL, first_space_index+1, data)\n\tobj_size := string((*data)[first_space_index:first_nul_index])\n\treturn strings.TrimSpace(obj_size), first_nul_index + 1\n}\n\nfunc getHead() {\n\n}\n\nfunc newObject(object_path string) *Object {\n\tzlib_bytes, err := ioutil.ReadFile(object_path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\/\/ zlib expects an io.Reader object\n\treader, err := zlib.NewReader(bytes.NewReader(zlib_bytes))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tbytes, err := ioutil.ReadAll(reader)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdata_ptr := &bytes\n\tobj_type, first_space_index := getType(data_ptr)\n\tsize, content_start_index := getSize(first_space_index, data_ptr)\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\treturn &Object{obj_type, size, object_path, object_dir + filepath.Base(object_path), bytes[content_start_index:]}\n}\n\nfunc (obj *Object) toJson() string {\n\tswitch obj.obj_type {\n\tcase \"tree\":\n\t\tentries := parseTree(obj)\n\t\toutput := \"[\\n\"\n\t\tfor i, entry := range entries {\n\t\t\tif i == len(entries)-1 {\n\t\t\t\toutput += entry.toJson() + \"\\n\"\n\t\t\t} else {\n\t\t\t\toutput += entry.toJson() + \",\\n\"\n\t\t\t}\n\t\t}\n\t\treturn output + \"]\\n\"\n\tcase \"commit\":\n\t\tcommit := parseCommit(obj)\n\t\tparents, _ := json.Marshal(commit.parents)\n\t\treturn fmt.Sprintf(\"{ \\\"parents\\\": %s, \\\"tree\\\": \\\"%s\\\"}\", string(parents), commit.tree)\n\tcase \"blob\":\n\t\treturn \"\\\"\\\"\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"I'm a %s\\n\", obj.obj_type)\n\t}\n}\n\ntype TreeEntry struct {\n\tmode string\n\tname string\n\thash string\n}\n\nfunc (e *TreeEntry) toJson() string {\n\treturn fmt.Sprintf(\"{\\\"mode\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\", \\\"hash\\\": \\\"%s\\\"}\", e.mode, e.name, e.hash)\n}\n\ntype Commit struct {\n\ttree    string\n\tparents []string\n}\n\ntype Repo struct {\n\tlocation string\n}\n\nfunc getObjectName(object_path string) string {\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\tname := object_dir + filepath.Base(object_path)\n\treturn name\n}\n\nfunc (r *Repo) getObject(name string) *Object {\n\tvar obj *Object\n\tfilepath.WalkDir(r.location+\"\/.git\/objects\", func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tis_hex, err := regexp.MatchString(\"^[a-fA-F0-9]+$\", filepath.Base(path))\n\t\tif !d.IsDir() && is_hex && getObjectName(path) == name {\n\t\t\tobj = newObject(path)\n\t\t\t\/\/fmt.Printf(\"\\\"%s\\\": {\\\"type\\\": \\\"%s\\\", \\\"size\\\": \\\"%s\\\", \\\"content\\\": %s},\\n\", obj.name, obj.obj_type, obj.size, obj.toJson())\n\t\t}\n\t\treturn nil\n\t})\n\treturn obj\n}\n\nfunc newRepo(location string) *Repo {\n\treturn &Repo{location}\n}\n\nfunc parseTree(obj *Object) []TreeEntry {\n\tvar entries []TreeEntry\n\tentry_item, start, stop := 1, 0, 6\n\tmode, name, hash := \"\", \"\", \"\"\n\tfor stop <= len(obj.content) {\n\t\tswitch entry_item {\n\t\t\/\/ get the mode\n\t\tcase 1:\n\t\t\tmode = strings.TrimSpace(string(obj.content[start:stop]))\n\t\t\tentry_item += 1\n\t\t\tstart = stop\n\t\t\/\/ get the name (file or dir)\n\t\tcase 2:\n\t\t\ti := start\n\t\t\tfor obj.content[i] != NUL && i < len(obj.content)-1 {\n\t\t\t\ti += 1\n\t\t\t}\n\t\t\tname = strings.TrimSpace(string(obj.content[start:i]))\n\t\t\tentry_item += 1\n\t\t\tstart = i + 1\n\t\t\tstop = start + 20\n\t\t\/\/ get the hash (object name)\n\t\tcase 3:\n\t\t\thash = strings.TrimSpace(hex.EncodeToString(obj.content[start:stop]))\n\t\t\tentry_item = 1\n\t\t\tstart = stop\n\t\t\tstop = start + 6\n\t\t\tentries = append(entries, TreeEntry{mode, name, hash})\n\t\t}\n\t}\n\treturn entries\n}\n\nfunc parseCommit(obj *Object) Commit {\n\ttree_hash := string(obj.content[5:45])\n\trest_of_content := strings.Split(string(obj.content[46:]), \"\\n\")\n\tvar parents []string\n\tfor _, line := range rest_of_content {\n\t\tif line[:6] == \"parent\" {\n\t\t\tparents = append(parents, line[7:47])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn Commit{tree_hash, parents}\n}\n\nfunc main() {\n\trepo := newRepo(\"\/Users\/joebob\/Desktop\/mkdocs-multirepo-plugin\")\n\tobj := repo.getObject(\"1091c15ba4616576ca28fc71dd1532f540500fae\")\n\tfmt.Println(obj.toJson())\n}\n"
        ],
        [
            "4ace0c14f0ed8026c2df67a1e183988133904d33",
            "blob",
            "package main\n\nimport (\n\t\"bytes\"\n\t\"compress\/zlib\"\n\t\"encoding\/hex\"\n\t\"fmt\"\n\t\"io\/fs\"\n\t\"io\/ioutil\"\n\t\"os\"\n\t\"path\/filepath\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nconst (\n\tSPACE byte = 32\n\tNUL   byte = 0\n)\n\ntype Object struct {\n\tobj_type string\n\tsize     string\n\tlocation string\n\tname     string\n\tcontent  []byte\n}\n\ntype TreeEntry struct {\n\tmode string\n\tname string\n\thash string\n}\n\ntype Commit struct {\n\ttree    string\n\tparents []string\n}\n\nfunc getObjectsData(s string, d fs.DirEntry, err error) error {\n\tif err != nil {\n\t\treturn err\n\t}\n\tis_hex, err := regexp.MatchString(\"^[a-fA-F0-9]+$\", filepath.Base(s))\n\tif !d.IsDir() && is_hex {\n\t\tprintln(s)\n\t\tvar obj *Object = newObject(s)\n\t\tfmt.Printf(\"{type: \\\"%s\\\", size: \\\"%s\\\", content: %s}\\n\", obj.obj_type, obj.size, obj.toJson())\n\t}\n\treturn nil\n}\n\n\/\/ Given a byte find the first byte in a data slice that equals the match_byte, returning the index.\n\/\/ If no match is found, returns -1\nfunc findFirstMatch(match_byte byte, start_index int, data *[]byte) int {\n\tfor i, this_byte := range (*data)[start_index:] {\n\t\tif this_byte == match_byte {\n\t\t\treturn start_index + i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc getType(data *[]byte) (string, int) {\n\tfirst_space_index := findFirstMatch(SPACE, 0, data)\n\tobj_type := string((*data)[0:first_space_index])\n\treturn strings.TrimSpace(obj_type), first_space_index\n}\n\n\/\/ second return value is the start of the object's content\nfunc getSize(first_space_index int, data *[]byte) (string, int) {\n\tfirst_nul_index := findFirstMatch(NUL, first_space_index+1, data)\n\tobj_size := string((*data)[first_space_index:first_nul_index])\n\treturn strings.TrimSpace(obj_size), first_nul_index + 1\n}\n\nfunc parseTree(obj *Object) []TreeEntry {\n\tvar entries []TreeEntry\n\tentry_item, start, stop := 1, 0, 6\n\tmode, name, hash := \"\", \"\", \"\"\n\tfor stop <= len(obj.content) {\n\t\tswitch entry_item {\n\t\t\/\/ get the mode\n\t\tcase 1:\n\t\t\tmode = strings.TrimSpace(string(obj.content[start:stop]))\n\t\t\tentry_item += 1\n\t\t\tstart = stop\n\t\t\/\/ get the name (file or dir)\n\t\tcase 2:\n\t\t\ti := start\n\t\t\tfor obj.content[i] != NUL && i < len(obj.content)-1 {\n\t\t\t\ti += 1\n\t\t\t}\n\t\t\tname = strings.TrimSpace(string(obj.content[start:i]))\n\t\t\tentry_item += 1\n\t\t\tstart = i + 1\n\t\t\tstop = start + 20\n\t\t\/\/ get the hash (object name)\n\t\tcase 3:\n\t\t\thash = strings.TrimSpace(hex.EncodeToString(obj.content[start:stop]))\n\t\t\tentry_item = 1\n\t\t\tstart = stop\n\t\t\tstop = start + 6\n\t\t\tentries = append(entries, TreeEntry{mode, name, hash})\n\t\t}\n\t}\n\treturn entries\n}\n\nfunc parseCommit(obj *Object) Commit {\n\ttree_hash := string(obj.content[5:45])\n\trest_of_content := strings.Split(string(obj.content[46:]), \"\\n\")\n\tvar parents []string\n\tfor _, line := range rest_of_content {\n\t\tif line[:6] == \"parent\" {\n\t\t\tparents = append(parents, line[7:47])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn Commit{tree_hash, parents}\n}\n\nfunc newObject(object_path string) *Object {\n\tzlib_bytes, err := ioutil.ReadFile(object_path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\/\/ zlib expects an io.Reader object\n\treader, err := zlib.NewReader(bytes.NewReader(zlib_bytes))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tbytes, err := ioutil.ReadAll(reader)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdata_ptr := &bytes\n\tobj_type, first_space_index := getType(data_ptr)\n\tsize, content_start_index := getSize(first_space_index, data_ptr)\n\treturn &Object{obj_type, size, object_path, filepath.Base(object_path), bytes[content_start_index:]}\n}\n\nfunc (obj *Object) toJson() string {\n\tswitch obj.obj_type {\n\tcase \"tree\":\n\t\tentries := parseTree(obj)\n\t\toutput := \"[\\n\"\n\t\tfor i, entry := range entries {\n\t\t\tif i == len(entries)-1 {\n\t\t\t\toutput += fmt.Sprintf(\"{mode: \\\"%s\\\", name: \\\"%s\\\", hash: \\\"%s\\\"}\\n\", entry.mode, entry.name, entry.hash)\n\t\t\t} else {\n\t\t\t\toutput += fmt.Sprintf(\"{mode: \\\"%s\\\", name: \\\"%s\\\", hash: \\\"%s\\\"},\\n\", entry.mode, entry.name, entry.hash)\n\t\t\t}\n\t\t}\n\t\treturn output + \"]\\n\"\n\tcase \"commit\":\n\t\tcommit := parseCommit(obj)\n\t\treturn fmt.Sprintf(\"{ parents: %s, tree: \\\"%s\\\"}\", commit.parents, commit.tree)\n\tcase \"blob\":\n\t\treturn \"I'm a blob\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"I'm a %s\\n\", obj.obj_type)\n\t}\n}\n\nfunc main() {\n\tfilepath.WalkDir(os.Args[1], getObjectsData)\n}\n"
        ],
        [
            "66fd13c903cac02eb9657cd53fb227823484401d",
            "blob",
            "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor\/\n"
        ],
        [
            "7a895999e1fa52604c4aff0fe04735f1ee9b8b38",
            "tree",
            "[\n{\"mode\": \"100644\", \"name\": \".gitignore\", \"hash\": \"66fd13c903cac02eb9657cd53fb227823484401d\"},\n{\"mode\": \"100644\", \"name\": \"LICENSE\", \"hash\": \"9adcb40f927482119da665a20b8379ab8e161c8a\"},\n{\"mode\": \"100644\", \"name\": \"README.md\", \"hash\": \"5803288b25eb0cfc5fc8648645a43b767290dcdc\"},\n{\"mode\": \"100644\", \"name\": \"git.go\", \"hash\": \"c3d4b48e92403a3a09e0569ee5938d44b52816c4\"},\n{\"mode\": \"100644\", \"name\": \"util.go\", \"hash\": \"9b62d000c5a39450d7d4791a9f0cc7e11cf8a6fe\"}\n]\n"
        ],
        [
            "7b68193936a0b4845077bc9c55a29d33305db281",
            "tree",
            "[\n{\"mode\": \"100644\", \"name\": \".gitignore\", \"hash\": \"66fd13c903cac02eb9657cd53fb227823484401d\"},\n{\"mode\": \"100644\", \"name\": \"LICENSE\", \"hash\": \"9adcb40f927482119da665a20b8379ab8e161c8a\"},\n{\"mode\": \"100644\", \"name\": \"README.md\", \"hash\": \"5803288b25eb0cfc5fc8648645a43b767290dcdc\"},\n{\"mode\": \"100644\", \"name\": \"git.go\", \"hash\": \"2d6d979b7360d8612fb31a44e3f8ba3b9d0a8c3a\"}\n]\n"
        ],
        [
            "8ba03390d7110a85a2203b9e86ed19c0bafa885e",
            "commit",
            "{\"parents\": [\"55fc311d85bd902f177474d2245e56ad0225ab2c\"], \"tree\": \"d22f049d14ff1c4be60cdc38ee8e59163e6112ba\"}"
        ],
        [
            "04cae2c8019c039782fac140c206e93ce0066cca",
            "blob",
            "module github.com\/gogit\n\ngo 1.19\n\nrequire (\n\tgithub.com\/cpuguy83\/go-md2man\/v2 v2.0.2 \/\/ indirect\n\tgithub.com\/mattn\/go-sqlite3 v1.14.22 \/\/ indirect\n\tgithub.com\/russross\/blackfriday\/v2 v2.1.0 \/\/ indirect\n\tgithub.com\/urfave\/cli\/v2 v2.27.1 \/\/ indirect\n\tgithub.com\/xrash\/smetrics v0.0.0-20201216005158-039620a65673 \/\/ indirect\n)\n"
        ],
        [
            "55fc311d85bd902f177474d2245e56ad0225ab2c",
            "commit",
            "{\"parents\": [\"44026eba6243475c7164548b79ee2266b4e5c9eb\"], \"tree\": \"adaf9feb6a90bfc9191f574d15f4d0681ed821b9\"}"
        ],
        [
            "662ab20ee2d47d357133c488db8c6a426e6647e6",
            "blob",
            "package main\n\nimport (\n\t\"bytes\"\n\t\"compress\/zlib\"\n\t\"database\/sql\"\n\t\"encoding\/hex\"\n\t\"encoding\/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io\/fs\"\n\t\"log\"\n\t\"os\"\n\t\"path\/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t_ \"github.com\/mattn\/go-sqlite3\"\n\t\"github.com\/schollz\/progressbar\/v3\"\n\t\"github.com\/urfave\/cli\/v2\"\n)\n\n\/\/ Given a byte find the first byte in a data slice that equals the match_byte, returning the index.\n\/\/ If no match is found, returns -1\nfunc findFirstMatch(match_byte byte, start_index int, data *[]byte) int {\n\tfor i, this_byte := range (*data)[start_index:] {\n\t\tif this_byte == match_byte {\n\t\t\treturn start_index + i\n\t\t}\n\t}\n\treturn -1\n}\n\nconst (\n\tSPACE    byte   = 32\n\tNUL      byte   = 0\n\tGIT_DIR  string = \".git\"\n\tOBJS_DIR string = \"\/.git\/objects\"\n\tHEAD_LOC string = \"\/.git\/HEAD\"\n)\n\ntype Object struct {\n\ttype_    string `json:\"type\"`\n\tsize     string `json:\"size\"`\n\tlocation string `json:\"location\"`\n\tname     string `json:\"name\"`\n\tcontent  []byte `json:\"content\"`\n}\n\ntype TreeEntry struct {\n\tmode string\n\tname string\n\thash string\n}\n\ntype Commit struct {\n\ttree    string\n\tparents []string\n}\n\ntype Repo struct {\n\tlocation string\n\tobjects  map[string]*Object\n}\n\nfunc getType(data *[]byte) (string, int) {\n\tfirst_space_index := findFirstMatch(SPACE, 0, data)\n\ttype_ := string((*data)[0:first_space_index])\n\treturn strings.TrimSpace(type_), first_space_index\n}\n\n\/\/ second return value is the start of the object's content\nfunc getSize(first_space_index int, data *[]byte) (string, int) {\n\tfirst_nul_index := findFirstMatch(NUL, first_space_index+1, data)\n\tobj_size := string((*data)[first_space_index:first_nul_index])\n\treturn strings.TrimSpace(obj_size), first_nul_index + 1\n}\n\nfunc newObject(object_path string) *Object {\n\tzlib_bytes, err := os.ReadFile(object_path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t\/\/ zlib expects an io.Reader object\n\treader, err := zlib.NewReader(bytes.NewReader(zlib_bytes))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tbytes, err := io.ReadAll(reader)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdata_ptr := &bytes\n\ttype_, first_space_index := getType(data_ptr)\n\tsize, content_start_index := getSize(first_space_index, data_ptr)\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\treturn &Object{type_, size, object_path, object_dir + filepath.Base(object_path), bytes[content_start_index:]}\n}\n\nfunc (obj *Object) toJson() string {\n\tswitch obj.type_ {\n\tcase \"tree\":\n\t\tentries := parseTree(obj)\n\t\toutput := \"[\\n\"\n\t\tfor i, entry := range entries {\n\t\t\tif i == len(entries)-1 {\n\t\t\t\toutput += entry.toJson() + \"\\n\"\n\t\t\t} else {\n\t\t\t\toutput += entry.toJson() + \",\\n\"\n\t\t\t}\n\t\t}\n\t\treturn output + \"]\\n\"\n\tcase \"commit\":\n\t\tcommit := parseCommit(obj)\n\t\tparents, _ := json.Marshal(commit.parents)\n\t\treturn fmt.Sprintf(`{\"parents\": %s, \"tree\": \"%s\"}`, string(parents), commit.tree)\n\tcase \"blob\":\n\t\treturn \"\\\"\" + strings.Replace(string(obj.content), `\"`, `\\\"`, -1) + \"\\\"\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"I'm a %s\\n\", obj.type_)\n\t}\n}\n\nfunc (e *TreeEntry) toJson() string {\n\treturn fmt.Sprintf(`{\"mode\": \"%s\", \"name\": \"%s\", \"hash\": \"%s\"}`, e.mode, e.name, e.hash)\n}\n\nfunc getObjectName(object_path string) string {\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\tname := object_dir + filepath.Base(object_path)\n\treturn name\n}\n\nfunc getObjects(objects_dir string) map[string]*Object {\n\tvar objects map[string]*Object = make(map[string]*Object)\n\tfilepath.WalkDir(objects_dir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tis_hex, err := regexp.MatchString(\"^[a-fA-F0-9]+$\", filepath.Base(path))\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif !d.IsDir() && is_hex {\n\t\t\tobj := newObject(path)\n\t\t\tobjects[obj.name] = obj\n\t\t}\n\t\treturn nil\n\t})\n\treturn objects\n}\n\nfunc newRepo(location string) *Repo {\n\tobjects := getObjects(location + OBJS_DIR)\n\treturn &Repo{location, objects}\n}\n\nfunc (r *Repo) getObject(name string) *Object {\n\treturn r.objects[name]\n}\n\nfunc exec(db *sql.DB, query string) sql.Result {\n\tresult, err := db.Exec(query)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn result\n}\n\nfunc (r *Repo) toSQLite(path string) {\n\tos.Remove(path)\n\n\tdb, err := sql.Open(\"sqlite3\", path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\texec(db, `create table objects (name text primary key, type text, object jsonb);`)\n\texec(db, `create table edges (src text, dest text);`)\n\tobjs_stmt, err := db.Prepare(\"insert into objects(name, type, object) values(?, ?, ?)\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tedges_stmt, err := db.Prepare(\"insert into edges(src, dest) values(?, ?)\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer objs_stmt.Close()\n\tdefer edges_stmt.Close()\n\n\tfmt.Println(\"[info] generating Git SQLite database...\")\n\tbar := progressbar.Default(int64(len(r.objects)))\n\tfor name, obj := range r.objects {\n\t\t_, err = objs_stmt.Exec(name, obj.type_, obj.toJson())\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tswitch obj.type_ {\n\t\tcase \"commit\":\n\t\t\tcommit := parseCommit(obj)\n\t\t\t\/\/ commit edges to parents\n\t\t\tfor _, p := range commit.parents {\n\t\t\t\t_, err = edges_stmt.Exec(obj.name, p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ commit edge to tree\n\t\t\t_, err = edges_stmt.Exec(obj.name, commit.tree)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\tcase \"tree\":\n\t\t\tentries := parseTree(obj)\n\t\t\t\/\/ tree to blob edges\n\t\t\tfor _, entry := range entries {\n\t\t\t\t_, err = edges_stmt.Exec(obj.name, entry.hash)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbar.Add(1)\n\t}\n}\n\nfunc (r *Repo) refresh() {\n\tobjects := getObjects(r.location)\n\tr.objects = objects\n}\n\nfunc (r *Repo) head() string {\n\tbytes, err := os.ReadFile(r.location + HEAD_LOC)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn strings.TrimSpace(strings.Split(string(bytes), \":\")[1])\n}\n\nfunc (r *Repo) branch() string {\n\treturn filepath.Base(r.head())\n}\n\nfunc (r *Repo) currentCommit() Commit {\n\tbytes, err := os.ReadFile(r.location + fmt.Sprintf(\"\/%s\/\", GIT_DIR) + r.head())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn parseCommit(r.getObject(strings.TrimSpace(string(bytes))))\n}\n\nfunc parseTree(obj *Object) []TreeEntry {\n\tvar entries []TreeEntry\n\tcontent_len := len(obj.content)\n\tentry_item, start, stop := 1, 0, 6 \/\/ TODO: don't use magic numbers. Define constants.\n\tmode, name, hash := \"\", \"\", \"\"\n\tfor stop <= content_len {\n\t\tswitch entry_item {\n\t\t\/\/ get the mode\n\t\tcase 1:\n\t\t\tmode = strings.TrimSpace(string(obj.content[start:stop]))\n\t\t\tentry_item += 1\n\t\t\tstart = stop\n\t\t\/\/ get the name (file or dir)\n\t\tcase 2:\n\t\t\ti := start\n\t\t\tfor obj.content[i] != NUL && i < content_len-1 {\n\t\t\t\ti += 1\n\t\t\t}\n\t\t\tname = strings.TrimSpace(string(obj.content[start:i]))\n\t\t\tentry_item += 1\n\t\t\tstart = i + 1\n\t\t\tstop = start + 20 \/\/ TODO: don't use magic numbers. Define constants.\n\t\t\/\/ get the hash (object name)\n\t\tcase 3:\n\t\t\thash = strings.TrimSpace(hex.EncodeToString(obj.content[start:stop]))\n\t\t\tentry_item = 1\n\t\t\tstart = stop\n\t\t\tstop = start + 6 \/\/ TODO: don't use magic numbers. Define constants.\n\t\t\tentries = append(entries, TreeEntry{mode, name, hash})\n\t\t}\n\t}\n\treturn entries\n}\n\nfunc parseCommit(obj *Object) Commit {\n\ttree_hash := string(obj.content[5:45])                           \/\/ TODO: don't use magic numbers. Define constants.\n\trest_of_content := strings.Split(string(obj.content[46:]), \"\\n\") \/\/ TODO: don't use magic numbers. Define constants.\n\tvar parents []string\n\tfor _, line := range rest_of_content {\n\t\tif line[:6] == \"parent\" {\n\t\t\tparents = append(parents, line[7:47]) \/\/ TODO: don't use magic numbers. Define constants.\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn Commit{tree_hash, parents}\n}\n\nfunc main() {\n\n\tapp := &cli.App{\n\t\tUseShortOptionHandling: true,\n\t\tName:                   \"gogit\",\n\t\tVersion:                \"v1.0.0\",\n\t\tCompiled:               time.Now(),\n\t\tAuthors: []*cli.Author{\n\t\t\t&cli.Author{\n\t\t\t\tName:  \"Joseph Doiron\",\n\t\t\t\tEmail: \"\",\n\t\t\t},\n\t\t},\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"repo-path\",\n\t\t\t\tValue:   \".\",\n\t\t\t\tAliases: []string{\"r\"},\n\t\t\t\tUsage:   \"\",\n\t\t\t},\n\t\t},\n\t\tCommands: []*cli.Command{\n\t\t\t{\n\t\t\t\tName:  \"to-sqlite\",\n\t\t\t\tUsage: \"Generates a SQLite database representing the Git repo.\",\n\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t&cli.StringFlag{\n\t\t\t\t\t\tName:    \"db-path\",\n\t\t\t\t\t\tValue:   \"git.sqlite\",\n\t\t\t\t\t\tAliases: []string{\"d\"},\n\t\t\t\t\t\tUsage:   \"The path to the database to output.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tAction: func(cCtx *cli.Context) error {\n\t\t\t\t\trepo := newRepo(cCtx.String(\"repo-path\"))\n\t\t\t\t\trepo.toSQLite(cCtx.String(\"db-path\"))\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"show\",\n\t\t\t\tUsage: \"Shows the content of a Git object.\",\n\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t&cli.StringFlag{\n\t\t\t\t\t\tName:     \"object\",\n\t\t\t\t\t\tAliases:  []string{\"o\"},\n\t\t\t\t\t\tUsage:    \"Pass multiple greetings\",\n\t\t\t\t\t\tRequired: true,\n\t\t\t\t\t},\n\t\t\t\t\t&cli.BoolFlag{Name: \"type\", Aliases: []string{\"t\"}},\n\t\t\t\t},\n\t\t\t\tAction: func(cCtx *cli.Context) error {\n\t\t\t\t\tobj := newRepo(cCtx.String(\"repo-path\")).getObject(cCtx.String(\"object\"))\n\t\t\t\t\tif cCtx.Bool(\"type\") {\n\t\t\t\t\t\tfmt.Println(obj.type_)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfmt.Println(obj.toJson())\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := app.Run(os.Args); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"
        ],
        [
            "5793c3c209578f49489920aade19033519e7aa36",
            "blob",
            "package main\n\nimport (\n\t\"bytes\"\n\t\"compress\/zlib\"\n\t\"database\/sql\"\n\t\"encoding\/hex\"\n\t\"encoding\/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io\/fs\"\n\t\"log\"\n\t\"os\"\n\t\"path\/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t_ \"github.com\/mattn\/go-sqlite3\"\n\t\"github.com\/schollz\/progressbar\/v3\"\n\t\"github.com\/urfave\/cli\/v2\"\n)\n\n\/\/ Given a byte find the first byte in a data slice that equals the match_byte, returning the index.\n\/\/ If no match is found, returns -1\nfunc findFirstMatch(match_byte byte, start_index int, data *[]byte) int {\n\tfor i, this_byte := range (*data)[start_index:] {\n\t\tif this_byte == match_byte {\n\t\t\treturn start_index + i\n\t\t}\n\t}\n\treturn -1\n}\n\nconst (\n\tSPACE byte = 32\n\tNUL   byte = 0\n)\n\ntype Object struct {\n\ttype_    string `json:\"type\"`\n\tsize     string `json:\"size\"`\n\tlocation string `json:\"location\"`\n\tname     string `json:\"name\"`\n\tcontent  []byte `json:\"content\"`\n}\n\ntype TreeEntry struct {\n\tmode string\n\tname string\n\thash string\n}\n\ntype Commit struct {\n\ttree    string\n\tparents []string\n}\n\ntype Repo struct {\n\tlocation string\n\tobjects  map[string]*Object\n}\n\nfunc getType(data *[]byte) (string, int) {\n\tfirst_space_index := findFirstMatch(SPACE, 0, data)\n\ttype_ := string((*data)[0:first_space_index])\n\treturn strings.TrimSpace(type_), first_space_index\n}\n\n\/\/ second return value is the start of the object's content\nfunc getSize(first_space_index int, data *[]byte) (string, int) {\n\tfirst_nul_index := findFirstMatch(NUL, first_space_index+1, data)\n\tobj_size := string((*data)[first_space_index:first_nul_index])\n\treturn strings.TrimSpace(obj_size), first_nul_index + 1\n}\n\nfunc newObject(object_path string) *Object {\n\tzlib_bytes, err := os.ReadFile(object_path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\/\/ zlib expects an io.Reader object\n\treader, err := zlib.NewReader(bytes.NewReader(zlib_bytes))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tbytes, err := io.ReadAll(reader)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdata_ptr := &bytes\n\ttype_, first_space_index := getType(data_ptr)\n\tsize, content_start_index := getSize(first_space_index, data_ptr)\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\treturn &Object{type_, size, object_path, object_dir + filepath.Base(object_path), bytes[content_start_index:]}\n}\n\nfunc (obj *Object) toJson() string {\n\tswitch obj.type_ {\n\tcase \"tree\":\n\t\tentries := parseTree(obj)\n\t\toutput := \"[\\n\"\n\t\tfor i, entry := range entries {\n\t\t\tif i == len(entries)-1 {\n\t\t\t\toutput += entry.toJson() + \"\\n\"\n\t\t\t} else {\n\t\t\t\toutput += entry.toJson() + \",\\n\"\n\t\t\t}\n\t\t}\n\t\treturn output + \"]\\n\"\n\tcase \"commit\":\n\t\tcommit := parseCommit(obj)\n\t\tparents, _ := json.Marshal(commit.parents)\n\t\treturn fmt.Sprintf(`{\"parents\": %s, \"tree\": \"%s\"}`, string(parents), commit.tree)\n\tcase \"blob\":\n\t\treturn \"\\\"\" + strings.Replace(string(obj.content), `\"`, `\\\"`, -1) + \"\\\"\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"I'm a %s\\n\", obj.type_)\n\t}\n}\n\nfunc (e *TreeEntry) toJson() string {\n\treturn fmt.Sprintf(`{\"mode\": \"%s\", \"name\": \"%s\", \"hash\": \"%s\"}`, e.mode, e.name, e.hash)\n}\n\nfunc getObjectName(object_path string) string {\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\tname := object_dir + filepath.Base(object_path)\n\treturn name\n}\n\nfunc getObjects(objects_dir string) map[string]*Object {\n\tvar objects map[string]*Object\n\tobjects = make(map[string]*Object)\n\tfilepath.WalkDir(objects_dir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tis_hex, err := regexp.MatchString(\"^[a-fA-F0-9]+$\", filepath.Base(path))\n\t\tif !d.IsDir() && is_hex {\n\t\t\tobj := newObject(path)\n\t\t\tobjects[obj.name] = obj\n\t\t}\n\t\treturn nil\n\t})\n\treturn objects\n}\n\nfunc newRepo(location string) *Repo {\n\tobjects := getObjects(location + \"\/.git\/objects\")\n\treturn &Repo{location, objects}\n}\n\nfunc (r *Repo) getObject(name string) *Object {\n\treturn r.objects[name]\n}\n\nfunc exec(db *sql.DB, query string) sql.Result {\n\tresult, err := db.Exec(query)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn result\n}\n\nfunc (r *Repo) toSQLite(path string) {\n\tos.Remove(path)\n\n\tdb, err := sql.Open(\"sqlite3\", path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\texec(db, `create table objects (name text primary key, type text, object jsonb);`)\n\texec(db, `create table edges (src text, dest text);`)\n\tobjs_stmt, err := db.Prepare(\"insert into objects(name, type, object) values(?, ?, ?)\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tedges_stmt, err := db.Prepare(\"insert into edges(src, dest) values(?, ?)\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer objs_stmt.Close()\n\tdefer edges_stmt.Close()\n\n\tfmt.Println(\"[info] generating Git SQLite database...\")\n\tbar := progressbar.Default(int64(len(r.objects)))\n\tfor name, obj := range r.objects {\n\t\t_, err = objs_stmt.Exec(name, obj.type_, obj.toJson())\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tswitch obj.type_ {\n\t\tcase \"commit\":\n\t\t\tcommit := parseCommit(obj)\n\t\t\t\/\/ commit edges to parents\n\t\t\tfor _, p := range commit.parents {\n\t\t\t\t_, err = edges_stmt.Exec(obj.name, p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ commit edge to tree\n\t\t\t_, err = edges_stmt.Exec(obj.name, commit.tree)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\tcase \"tree\":\n\t\t\tentries := parseTree(obj)\n\t\t\t\/\/ tree to blob edges\n\t\t\tfor _, entry := range entries {\n\t\t\t\t_, err = edges_stmt.Exec(obj.name, entry.hash)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbar.Add(1)\n\t}\n}\n\nfunc (r *Repo) refresh() {\n\tobjects := getObjects(r.location)\n\tr.objects = objects\n}\n\nfunc (r *Repo) head() string {\n\tbytes, err := os.ReadFile(r.location + \"\/.git\/HEAD\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn strings.TrimSpace(strings.Split(string(bytes), \":\")[1])\n}\n\nfunc (r *Repo) branch() string {\n\thead := r.head()\n\treturn filepath.Base(head)\n}\n\nfunc (r *Repo) current_commit() *Object {\n\tbytes, err := os.ReadFile(r.location + \"\/.git\/\" + r.head())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn r.getObject(strings.TrimSpace(string(bytes)))\n}\n\nfunc parseTree(obj *Object) []TreeEntry {\n\tvar entries []TreeEntry\n\tentry_item, start, stop := 1, 0, 6\n\tmode, name, hash := \"\", \"\", \"\"\n\tfor stop <= len(obj.content) {\n\t\tswitch entry_item {\n\t\t\/\/ get the mode\n\t\tcase 1:\n\t\t\tmode = strings.TrimSpace(string(obj.content[start:stop]))\n\t\t\tentry_item += 1\n\t\t\tstart = stop\n\t\t\/\/ get the name (file or dir)\n\t\tcase 2:\n\t\t\ti := start\n\t\t\tfor obj.content[i] != NUL && i < len(obj.content)-1 {\n\t\t\t\ti += 1\n\t\t\t}\n\t\t\tname = strings.TrimSpace(string(obj.content[start:i]))\n\t\t\tentry_item += 1\n\t\t\tstart = i + 1\n\t\t\tstop = start + 20\n\t\t\/\/ get the hash (object name)\n\t\tcase 3:\n\t\t\thash = strings.TrimSpace(hex.EncodeToString(obj.content[start:stop]))\n\t\t\tentry_item = 1\n\t\t\tstart = stop\n\t\t\tstop = start + 6\n\t\t\tentries = append(entries, TreeEntry{mode, name, hash})\n\t\t}\n\t}\n\treturn entries\n}\n\nfunc parseCommit(obj *Object) Commit {\n\ttree_hash := string(obj.content[5:45])\n\trest_of_content := strings.Split(string(obj.content[46:]), \"\\n\")\n\tvar parents []string\n\tfor _, line := range rest_of_content {\n\t\tif line[:6] == \"parent\" {\n\t\t\tparents = append(parents, line[7:47])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn Commit{tree_hash, parents}\n}\n\nfunc main() {\n\tvar repo_path string\n\tvar db_path string\n\n\tapp := &cli.App{\n\t\tUseShortOptionHandling: true,\n\t\tCommands: []*cli.Command{\n\t\t\t{\n\t\t\t\tName:  \"to-sqlite\",\n\t\t\t\tUsage: \"dfsdf\",\n\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t&cli.StringFlag{\n\t\t\t\t\t\tName:        \"repo-path\",\n\t\t\t\t\t\tValue:       \".\",\n\t\t\t\t\t\tAliases:     []string{\"r\"},\n\t\t\t\t\t\tDestination: &repo_path,\n\t\t\t\t\t\tUsage:       \"Pass multiple greetings\",\n\t\t\t\t\t},\n\t\t\t\t\t&cli.StringFlag{\n\t\t\t\t\t\tName:        \"db-path\",\n\t\t\t\t\t\tValue:       \"git.sqlite\",\n\t\t\t\t\t\tAliases:     []string{\"d\"},\n\t\t\t\t\t\tDestination: &db_path,\n\t\t\t\t\t\tUsage:       \"Pass multiple greetings\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tAction: func(cCtx *cli.Context) error {\n\t\t\t\t\trepo := newRepo(repo_path)\n\t\t\t\t\trepo.toSQLite(db_path)\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := app.Run(os.Args); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"
        ],
        [
            "9459eac0626138eb2c9fb5ccc76ced79264f61c0",
            "blob",
            "github.com\/cpuguy83\/go-md2man\/v2 v2.0.2 h1:p1EgwI\/C7NhT0JmVkwCD2ZBK8j4aeHQX2pMHHBfMQ6w=\ngithub.com\/cpuguy83\/go-md2man\/v2 v2.0.2\/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com\/mattn\/go-sqlite3 v1.14.22 h1:2gZY6PC6kBnID23Tichd1K+Z0oS6nE\/XwU+Vz\/5o4kU=\ngithub.com\/mattn\/go-sqlite3 v1.14.22\/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=\ngithub.com\/russross\/blackfriday\/v2 v2.1.0 h1:JIOH55\/0cWyOuilr9\/qlrm0BSXldqnqwMsf35Ld67mk=\ngithub.com\/russross\/blackfriday\/v2 v2.1.0\/go.mod h1:+Rmxgy9KzJVeS9\/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com\/urfave\/cli\/v2 v2.27.1 h1:8xSQ6szndafKVRmfyeUMxkNUJQMjL1F2zmsZ+qHpfho=\ngithub.com\/urfave\/cli\/v2 v2.27.1\/go.mod h1:8qnjx1vcq5s2\/wpsqoZFndg2CE5tNFyrTvS6SinrnYQ=\ngithub.com\/xrash\/smetrics v0.0.0-20201216005158-039620a65673 h1:bAn7\/zixMGCfxrRTfdpNzjtPYqr8smhKouy9mxVdGPU=\ngithub.com\/xrash\/smetrics v0.0.0-20201216005158-039620a65673\/go.mod h1:N3UwUGtsrSj3ccvlPHLoLsHnpR27oXr4ZE984MbSER8=\n"
        ],
        [
            "44026eba6243475c7164548b79ee2266b4e5c9eb",
            "commit",
            "{\"parents\": [\"47955a29880dcfbdfd390e4496fe6d48658f5bbc\"], \"tree\": \"285c6fd1c404e74ee57728715f1a050b70016125\"}"
        ],
        [
            "47955a29880dcfbdfd390e4496fe6d48658f5bbc",
            "commit",
            "{\"parents\": [\"00e24b73b0d73017b3e8a9d5fb680cc30e0db122\"], \"tree\": \"85e4bdc0c8c2e69ccb6101807abee1d1942515df\"}"
        ],
        [
            "4bf781d59924ed565b705ee3c8ca47d8326d168b",
            "blob",
            "package main\n\nimport (\n\t\"bytes\"\n\t\"compress\/zlib\"\n\t\"encoding\/hex\"\n\t\"encoding\/json\"\n\t\"fmt\"\n\t\"io\/fs\"\n\t\"io\/ioutil\"\n\t\"path\/filepath\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nconst (\n\tSPACE byte = 32\n\tNUL   byte = 0\n)\n\ntype Object struct {\n\tobj_type string\n\tsize     string\n\tlocation string\n\tname     string\n\tcontent  []byte\n}\n\n\/\/ Given a byte find the first byte in a data slice that equals the match_byte, returning the index.\n\/\/ If no match is found, returns -1\nfunc findFirstMatch(match_byte byte, start_index int, data *[]byte) int {\n\tfor i, this_byte := range (*data)[start_index:] {\n\t\tif this_byte == match_byte {\n\t\t\treturn start_index + i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc getType(data *[]byte) (string, int) {\n\tfirst_space_index := findFirstMatch(SPACE, 0, data)\n\tobj_type := string((*data)[0:first_space_index])\n\treturn strings.TrimSpace(obj_type), first_space_index\n}\n\n\/\/ second return value is the start of the object's content\nfunc getSize(first_space_index int, data *[]byte) (string, int) {\n\tfirst_nul_index := findFirstMatch(NUL, first_space_index+1, data)\n\tobj_size := string((*data)[first_space_index:first_nul_index])\n\treturn strings.TrimSpace(obj_size), first_nul_index + 1\n}\n\nfunc getHead() {\n\n}\n\nfunc newObject(object_path string) *Object {\n\tzlib_bytes, err := ioutil.ReadFile(object_path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\/\/ zlib expects an io.Reader object\n\treader, err := zlib.NewReader(bytes.NewReader(zlib_bytes))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tbytes, err := ioutil.ReadAll(reader)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdata_ptr := &bytes\n\tobj_type, first_space_index := getType(data_ptr)\n\tsize, content_start_index := getSize(first_space_index, data_ptr)\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\treturn &Object{obj_type, size, object_path, object_dir + filepath.Base(object_path), bytes[content_start_index:]}\n}\n\nfunc (obj *Object) toJson() string {\n\tswitch obj.obj_type {\n\tcase \"tree\":\n\t\tentries := parseTree(obj)\n\t\toutput := \"[\\n\"\n\t\tfor i, entry := range entries {\n\t\t\tif i == len(entries)-1 {\n\t\t\t\toutput += entry.toJson() + \"\\n\"\n\t\t\t} else {\n\t\t\t\toutput += entry.toJson() + \",\\n\"\n\t\t\t}\n\t\t}\n\t\treturn output + \"]\\n\"\n\tcase \"commit\":\n\t\tcommit := parseCommit(obj)\n\t\tparents, _ := json.Marshal(commit.parents)\n\t\treturn fmt.Sprintf(\"{ \\\"parents\\\": %s, \\\"tree\\\": \\\"%s\\\"}\", string(parents), commit.tree)\n\tcase \"blob\":\n\t\treturn \"\\\"\\\"\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"I'm a %s\\n\", obj.obj_type)\n\t}\n}\n\ntype TreeEntry struct {\n\tmode string\n\tname string\n\thash string\n}\n\nfunc (e *TreeEntry) toJson() string {\n\treturn fmt.Sprintf(\"{\\\"mode\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\", \\\"hash\\\": \\\"%s\\\"}\", e.mode, e.name, e.hash)\n}\n\ntype Commit struct {\n\ttree    string\n\tparents []string\n}\n\ntype Repo struct {\n\tlocation string\n\tobjects  map[string]*Object\n}\n\nfunc getObjectName(object_path string) string {\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\tname := object_dir + filepath.Base(object_path)\n\treturn name\n}\n\nfunc getObjects(objects_dir string) map[string]*Object {\n\tvar objects map[string]*Object\n\tobjects = make(map[string]*Object)\n\tfilepath.WalkDir(objects_dir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tis_hex, err := regexp.MatchString(\"^[a-fA-F0-9]+$\", filepath.Base(path))\n\t\tif !d.IsDir() && is_hex {\n\t\t\tobj := newObject(path)\n\t\t\tobjects[obj.name] = obj\n\t\t\t\/\/fmt.Printf(\"\\\"%s\\\": {\\\"type\\\": \\\"%s\\\", \\\"size\\\": \\\"%s\\\", \\\"content\\\": %s},\\n\", obj.name, obj.obj_type, obj.size, obj.toJson())\n\t\t}\n\t\treturn nil\n\t})\n\treturn objects\n}\n\nfunc newRepo(location string) *Repo {\n\tobjects := getObjects(location + \"\/.git\/objects\")\n\treturn &Repo{location, objects}\n}\n\nfunc (r *Repo) getObject(name string) *Object {\n\treturn r.objects[name]\n}\n\nfunc parseTree(obj *Object) []TreeEntry {\n\tvar entries []TreeEntry\n\tentry_item, start, stop := 1, 0, 6\n\tmode, name, hash := \"\", \"\", \"\"\n\tfor stop <= len(obj.content) {\n\t\tswitch entry_item {\n\t\t\/\/ get the mode\n\t\tcase 1:\n\t\t\tmode = strings.TrimSpace(string(obj.content[start:stop]))\n\t\t\tentry_item += 1\n\t\t\tstart = stop\n\t\t\/\/ get the name (file or dir)\n\t\tcase 2:\n\t\t\ti := start\n\t\t\tfor obj.content[i] != NUL && i < len(obj.content)-1 {\n\t\t\t\ti += 1\n\t\t\t}\n\t\t\tname = strings.TrimSpace(string(obj.content[start:i]))\n\t\t\tentry_item += 1\n\t\t\tstart = i + 1\n\t\t\tstop = start + 20\n\t\t\/\/ get the hash (object name)\n\t\tcase 3:\n\t\t\thash = strings.TrimSpace(hex.EncodeToString(obj.content[start:stop]))\n\t\t\tentry_item = 1\n\t\t\tstart = stop\n\t\t\tstop = start + 6\n\t\t\tentries = append(entries, TreeEntry{mode, name, hash})\n\t\t}\n\t}\n\treturn entries\n}\n\nfunc parseCommit(obj *Object) Commit {\n\ttree_hash := string(obj.content[5:45])\n\trest_of_content := strings.Split(string(obj.content[46:]), \"\\n\")\n\tvar parents []string\n\tfor _, line := range rest_of_content {\n\t\tif line[:6] == \"parent\" {\n\t\t\tparents = append(parents, line[7:47])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn Commit{tree_hash, parents}\n}\n\nfunc main() {\n\trepo := newRepo(\"\/Users\/joebob\/Desktop\/mkdocs-multirepo-plugin\")\n\tobj := repo.getObject(\"1091c15ba4616576ca28fc71dd1532f540500fae\")\n\tfmt.Println(obj.toJson())\n}\n"
        ],
        [
            "6ce963d85f6e453e3d2545871b047caadb91732b",
            "blob",
            "github.com\/cpuguy83\/go-md2man\/v2 v2.0.2 h1:p1EgwI\/C7NhT0JmVkwCD2ZBK8j4aeHQX2pMHHBfMQ6w=\ngithub.com\/cpuguy83\/go-md2man\/v2 v2.0.2\/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com\/davecgh\/go-spew v1.1.0\/go.mod h1:J7Y8YcW2NihsgmVo\/mv3lAwl\/skON4iLHjSsI+c5H38=\ngithub.com\/davecgh\/go-spew v1.1.1\/go.mod h1:J7Y8YcW2NihsgmVo\/mv3lAwl\/skON4iLHjSsI+c5H38=\ngithub.com\/k0kubun\/go-ansi v0.0.0-20180517002512-3bf9e2903213\/go.mod h1:vNUNkEQ1e29fT\/6vq2aBdFsgNPmy8qMdSay1npru+Sw=\ngithub.com\/mattn\/go-isatty v0.0.20\/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK\/D7dTCTo3Y=\ngithub.com\/mattn\/go-sqlite3 v1.14.22 h1:2gZY6PC6kBnID23Tichd1K+Z0oS6nE\/XwU+Vz\/5o4kU=\ngithub.com\/mattn\/go-sqlite3 v1.14.22\/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=\ngithub.com\/mitchellh\/colorstring v0.0.0-20190213212951-d06e56a500db h1:62I3jR2EmQ4l5rM\/4FEfDWcRD+abF5XlKShorW5LRoQ=\ngithub.com\/mitchellh\/colorstring v0.0.0-20190213212951-d06e56a500db\/go.mod h1:l0dey0ia\/Uv7NcFFVbCLtqEBQbrT4OCwCSKTEv6enCw=\ngithub.com\/pmezard\/go-difflib v1.0.0\/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ\/4=\ngithub.com\/rivo\/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com\/rivo\/uniseg v0.4.7\/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com\/russross\/blackfriday\/v2 v2.1.0 h1:JIOH55\/0cWyOuilr9\/qlrm0BSXldqnqwMsf35Ld67mk=\ngithub.com\/russross\/blackfriday\/v2 v2.1.0\/go.mod h1:+Rmxgy9KzJVeS9\/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com\/schollz\/progressbar\/v3 v3.14.2 h1:EducH6uNLIWsr560zSV1KrTeUb\/wZGAHqyMFIEa99ks=\ngithub.com\/schollz\/progressbar\/v3 v3.14.2\/go.mod h1:aQAZQnhF4JGFtRJiw\/eobaXpsqpVQAftEQ+hLGXaRc4=\ngithub.com\/stretchr\/objx v0.1.0\/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com\/stretchr\/testify v1.3.0\/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com\/urfave\/cli\/v2 v2.27.1 h1:8xSQ6szndafKVRmfyeUMxkNUJQMjL1F2zmsZ+qHpfho=\ngithub.com\/urfave\/cli\/v2 v2.27.1\/go.mod h1:8qnjx1vcq5s2\/wpsqoZFndg2CE5tNFyrTvS6SinrnYQ=\ngithub.com\/xrash\/smetrics v0.0.0-20201216005158-039620a65673 h1:bAn7\/zixMGCfxrRTfdpNzjtPYqr8smhKouy9mxVdGPU=\ngithub.com\/xrash\/smetrics v0.0.0-20201216005158-039620a65673\/go.mod h1:N3UwUGtsrSj3ccvlPHLoLsHnpR27oXr4ZE984MbSER8=\ngolang.org\/x\/sys v0.6.0\/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org\/x\/sys v0.17.0 h1:25cE3gD+tdBA7lp7QfhuV+rJiE9YXTcS3VG1SqssI\/Y=\ngolang.org\/x\/sys v0.17.0\/go.mod h1:\/VUhepiaJMQUp4+oa\/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org\/x\/term v0.17.0 h1:mkTF7LCd6WGJNL3K1Ad7kwxNfYAW6a8a8QqtMblp\/4U=\ngolang.org\/x\/term v0.17.0\/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\n"
        ],
        [
            "c88d95727f2f481b6472730b2241eec0c9cb0242",
            "blob",
            "package main\n\nimport (\n\t\"bytes\"\n\t\"compress\/zlib\"\n\t\"database\/sql\"\n\t\"encoding\/hex\"\n\t\"encoding\/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io\/fs\"\n\t\"log\"\n\t\"os\"\n\t\"path\/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t_ \"github.com\/mattn\/go-sqlite3\"\n\t\"github.com\/urfave\/cli\/v2\"\n)\n\n\/\/ Given a byte find the first byte in a data slice that equals the match_byte, returning the index.\n\/\/ If no match is found, returns -1\nfunc findFirstMatch(match_byte byte, start_index int, data *[]byte) int {\n\tfor i, this_byte := range (*data)[start_index:] {\n\t\tif this_byte == match_byte {\n\t\t\treturn start_index + i\n\t\t}\n\t}\n\treturn -1\n}\n\nconst (\n\tSPACE byte = 32\n\tNUL   byte = 0\n)\n\ntype Object struct {\n\tobj_type string `json:\"type\"`\n\tsize     string `json:\"size\"`\n\tlocation string `json:\"location\"`\n\tname     string `json:\"name\"`\n\tcontent  []byte `json:\"content\"`\n}\n\ntype TreeEntry struct {\n\tmode string\n\tname string\n\thash string\n}\n\ntype Commit struct {\n\ttree    string\n\tparents []string\n}\n\ntype Repo struct {\n\tlocation string\n\tobjects  map[string]*Object\n}\n\nfunc getType(data *[]byte) (string, int) {\n\tfirst_space_index := findFirstMatch(SPACE, 0, data)\n\tobj_type := string((*data)[0:first_space_index])\n\treturn strings.TrimSpace(obj_type), first_space_index\n}\n\n\/\/ second return value is the start of the object's content\nfunc getSize(first_space_index int, data *[]byte) (string, int) {\n\tfirst_nul_index := findFirstMatch(NUL, first_space_index+1, data)\n\tobj_size := string((*data)[first_space_index:first_nul_index])\n\treturn strings.TrimSpace(obj_size), first_nul_index + 1\n}\n\nfunc newObject(object_path string) *Object {\n\tzlib_bytes, err := os.ReadFile(object_path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\/\/ zlib expects an io.Reader object\n\treader, err := zlib.NewReader(bytes.NewReader(zlib_bytes))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tbytes, err := io.ReadAll(reader)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdata_ptr := &bytes\n\tobj_type, first_space_index := getType(data_ptr)\n\tsize, content_start_index := getSize(first_space_index, data_ptr)\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\treturn &Object{obj_type, size, object_path, object_dir + filepath.Base(object_path), bytes[content_start_index:]}\n}\n\nfunc (obj *Object) toJson() string {\n\tswitch obj.obj_type {\n\tcase \"tree\":\n\t\tentries := parseTree(obj)\n\t\toutput := \"[\\n\"\n\t\tfor i, entry := range entries {\n\t\t\tif i == len(entries)-1 {\n\t\t\t\toutput += entry.toJson() + \"\\n\"\n\t\t\t} else {\n\t\t\t\toutput += entry.toJson() + \",\\n\"\n\t\t\t}\n\t\t}\n\t\treturn output + \"]\\n\"\n\tcase \"commit\":\n\t\tcommit := parseCommit(obj)\n\t\tparents, _ := json.Marshal(commit.parents)\n\t\treturn fmt.Sprintf(\"{ \\\"parents\\\": %s, \\\"tree\\\": \\\"%s\\\"}\", string(parents), commit.tree)\n\tcase \"blob\":\n\t\treturn \"\\\"\" + strings.Replace(string(obj.content), `\"`, `\\\"`, -1) + \"\\\"\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"I'm a %s\\n\", obj.obj_type)\n\t}\n}\n\nfunc (e *TreeEntry) toJson() string {\n\treturn fmt.Sprintf(\"{\\\"mode\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\", \\\"hash\\\": \\\"%s\\\"}\", e.mode, e.name, e.hash)\n}\n\nfunc getObjectName(object_path string) string {\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\tname := object_dir + filepath.Base(object_path)\n\treturn name\n}\n\nfunc getObjects(objects_dir string) map[string]*Object {\n\tvar objects map[string]*Object\n\tobjects = make(map[string]*Object)\n\tfilepath.WalkDir(objects_dir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tis_hex, err := regexp.MatchString(\"^[a-fA-F0-9]+$\", filepath.Base(path))\n\t\tif !d.IsDir() && is_hex {\n\t\t\tobj := newObject(path)\n\t\t\tobjects[obj.name] = obj\n\t\t}\n\t\treturn nil\n\t})\n\treturn objects\n}\n\nfunc newRepo(location string) *Repo {\n\tobjects := getObjects(location + \"\/.git\/objects\")\n\treturn &Repo{location, objects}\n}\n\nfunc (r *Repo) getObject(name string) *Object {\n\treturn r.objects[name]\n}\n\nfunc (r *Repo) toSQLite(path string) {\n\tos.Remove(path)\n\n\tdb, err := sql.Open(\"sqlite3\", path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(`create table objects (name text, type text, object jsonb)`)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tstmt, err := db.Prepare(\"insert into objects(name, type, object) values(?, ?, ?)\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\n\tfor name, obj := range r.objects {\n\t\t_, err = stmt.Exec(name, obj.obj_type, obj.toJson())\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc (r *Repo) refresh() {\n\tobjects := getObjects(r.location)\n\tr.objects = objects\n}\n\nfunc (r *Repo) head() string {\n\tbytes, err := os.ReadFile(r.location + \"\/.git\/HEAD\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn strings.TrimSpace(strings.Split(string(bytes), \":\")[1])\n}\n\nfunc (r *Repo) branch() string {\n\thead := r.head()\n\treturn filepath.Base(head)\n}\n\nfunc (r *Repo) current_commit() *Object {\n\tbytes, err := os.ReadFile(r.location + \"\/.git\/\" + r.head())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn r.getObject(strings.TrimSpace(string(bytes)))\n}\n\nfunc parseTree(obj *Object) []TreeEntry {\n\tvar entries []TreeEntry\n\tentry_item, start, stop := 1, 0, 6\n\tmode, name, hash := \"\", \"\", \"\"\n\tfor stop <= len(obj.content) {\n\t\tswitch entry_item {\n\t\t\/\/ get the mode\n\t\tcase 1:\n\t\t\tmode = strings.TrimSpace(string(obj.content[start:stop]))\n\t\t\tentry_item += 1\n\t\t\tstart = stop\n\t\t\/\/ get the name (file or dir)\n\t\tcase 2:\n\t\t\ti := start\n\t\t\tfor obj.content[i] != NUL && i < len(obj.content)-1 {\n\t\t\t\ti += 1\n\t\t\t}\n\t\t\tname = strings.TrimSpace(string(obj.content[start:i]))\n\t\t\tentry_item += 1\n\t\t\tstart = i + 1\n\t\t\tstop = start + 20\n\t\t\/\/ get the hash (object name)\n\t\tcase 3:\n\t\t\thash = strings.TrimSpace(hex.EncodeToString(obj.content[start:stop]))\n\t\t\tentry_item = 1\n\t\t\tstart = stop\n\t\t\tstop = start + 6\n\t\t\tentries = append(entries, TreeEntry{mode, name, hash})\n\t\t}\n\t}\n\treturn entries\n}\n\nfunc parseCommit(obj *Object) Commit {\n\ttree_hash := string(obj.content[5:45])\n\trest_of_content := strings.Split(string(obj.content[46:]), \"\\n\")\n\tvar parents []string\n\tfor _, line := range rest_of_content {\n\t\tif line[:6] == \"parent\" {\n\t\t\tparents = append(parents, line[7:47])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn Commit{tree_hash, parents}\n}\n\nfunc main() {\n\tapp := &cli.App{\n\t\tName: \"gogit\",\n\t\tAction: func(cCtx *cli.Context) error {\n\t\t\targs := cCtx.Args()\n\t\t\trepo := newRepo(args.Get(0))\n\t\t\tfmt.Println(\"Generating Git SQLite database...\")\n\t\t\trepo.toSQLite(args.Get(1))\n\t\t\tfmt.Println(\"Done generating database.\")\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tif err := app.Run(os.Args); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"
        ],
        [
            "d22f049d14ff1c4be60cdc38ee8e59163e6112ba",
            "tree",
            "[\n{\"mode\": \"100644\", \"name\": \".gitignore\", \"hash\": \"66fd13c903cac02eb9657cd53fb227823484401d\"},\n{\"mode\": \"100644\", \"name\": \"LICENSE\", \"hash\": \"9adcb40f927482119da665a20b8379ab8e161c8a\"},\n{\"mode\": \"100644\", \"name\": \"README.md\", \"hash\": \"e8a5a302af2aab3083e5f7275e9434c009150c5c\"},\n{\"mode\": \"100644\", \"name\": \"go.mod\", \"hash\": \"d3146cf1d7abec84ff9cc78996f6cbd114b0d0ff\"},\n{\"mode\": \"100644\", \"name\": \"go.sum\", \"hash\": \"6ce963d85f6e453e3d2545871b047caadb91732b\"},\n{\"mode\": \"100644\", \"name\": \"gogit.go\", \"hash\": \"662ab20ee2d47d357133c488db8c6a426e6647e6\"}\n]\n"
        ],
        [
            "e8a5a302af2aab3083e5f7275e9434c009150c5c",
            "blob",
            "# gogit\n\nParses Git object's directory and generates a SQLite database.\n"
        ],
        [
            "9adcb40f927482119da665a20b8379ab8e161c8a",
            "blob",
            "MIT License\n\nCopyright (c) 2022 Joseph Doiron\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        ],
        [
            "adaf9feb6a90bfc9191f574d15f4d0681ed821b9",
            "tree",
            "[\n{\"mode\": \"100644\", \"name\": \".gitignore\", \"hash\": \"66fd13c903cac02eb9657cd53fb227823484401d\"},\n{\"mode\": \"100644\", \"name\": \"LICENSE\", \"hash\": \"9adcb40f927482119da665a20b8379ab8e161c8a\"},\n{\"mode\": \"100644\", \"name\": \"README.md\", \"hash\": \"e8a5a302af2aab3083e5f7275e9434c009150c5c\"},\n{\"mode\": \"100644\", \"name\": \"go.mod\", \"hash\": \"d3146cf1d7abec84ff9cc78996f6cbd114b0d0ff\"},\n{\"mode\": \"100644\", \"name\": \"go.sum\", \"hash\": \"6ce963d85f6e453e3d2545871b047caadb91732b\"},\n{\"mode\": \"100644\", \"name\": \"gogit.go\", \"hash\": \"5793c3c209578f49489920aade19033519e7aa36\"}\n]\n"
        ],
        [
            "be2cddff4775a26ad7441b65fcf2c9ea2cc6d126",
            "commit",
            "{\"parents\": [\"937cb25dd4d341bf341ecc76c242808f215fa0f6\"], \"tree\": \"66c4c43e0134f09c8ae61d4bd30c6bbc47bf386f\"}"
        ],
        [
            "e57559ada48909cb03baf7c3bf0e43b2f40ed13d",
            "commit",
            "{\"parents\": [\"7ae80028cbf58eb4986e75e5ef5f8eb59b9055d4\"], \"tree\": \"ab98e5e9a8dfb48955cd8647ff578baa0f99f206\"}"
        ],
        [
            "285c6fd1c404e74ee57728715f1a050b70016125",
            "tree",
            "[\n{\"mode\": \"100644\", \"name\": \".gitignore\", \"hash\": \"66fd13c903cac02eb9657cd53fb227823484401d\"},\n{\"mode\": \"100644\", \"name\": \"LICENSE\", \"hash\": \"9adcb40f927482119da665a20b8379ab8e161c8a\"},\n{\"mode\": \"100644\", \"name\": \"README.md\", \"hash\": \"5803288b25eb0cfc5fc8648645a43b767290dcdc\"},\n{\"mode\": \"100644\", \"name\": \"go.mod\", \"hash\": \"d3146cf1d7abec84ff9cc78996f6cbd114b0d0ff\"},\n{\"mode\": \"100644\", \"name\": \"go.sum\", \"hash\": \"6ce963d85f6e453e3d2545871b047caadb91732b\"},\n{\"mode\": \"100644\", \"name\": \"gogit.go\", \"hash\": \"5793c3c209578f49489920aade19033519e7aa36\"}\n]\n"
        ],
        [
            "8a05daf2002461da0a5898ccb0a4d7e464f678fc",
            "blob",
            "package main\n\nimport (\n\t\"bytes\"\n\t\"compress\/zlib\"\n\t\"database\/sql\"\n\t\"encoding\/hex\"\n\t\"encoding\/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io\/fs\"\n\t\"log\"\n\t\"os\"\n\t\"path\/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t_ \"github.com\/mattn\/go-sqlite3\"\n\t\"github.com\/urfave\/cli\/v2\"\n)\n\n\/\/ Given a byte find the first byte in a data slice that equals the match_byte, returning the index.\n\/\/ If no match is found, returns -1\nfunc findFirstMatch(match_byte byte, start_index int, data *[]byte) int {\n\tfor i, this_byte := range (*data)[start_index:] {\n\t\tif this_byte == match_byte {\n\t\t\treturn start_index + i\n\t\t}\n\t}\n\treturn -1\n}\n\nconst (\n\tSPACE byte = 32\n\tNUL   byte = 0\n)\n\ntype Object struct {\n\ttype_    string `json:\"type\"`\n\tsize     string `json:\"size\"`\n\tlocation string `json:\"location\"`\n\tname     string `json:\"name\"`\n\tcontent  []byte `json:\"content\"`\n}\n\ntype TreeEntry struct {\n\tmode string\n\tname string\n\thash string\n}\n\ntype Commit struct {\n\ttree    string\n\tparents []string\n}\n\ntype Repo struct {\n\tlocation string\n\tobjects  map[string]*Object\n}\n\nfunc getType(data *[]byte) (string, int) {\n\tfirst_space_index := findFirstMatch(SPACE, 0, data)\n\ttype_ := string((*data)[0:first_space_index])\n\treturn strings.TrimSpace(type_), first_space_index\n}\n\n\/\/ second return value is the start of the object's content\nfunc getSize(first_space_index int, data *[]byte) (string, int) {\n\tfirst_nul_index := findFirstMatch(NUL, first_space_index+1, data)\n\tobj_size := string((*data)[first_space_index:first_nul_index])\n\treturn strings.TrimSpace(obj_size), first_nul_index + 1\n}\n\nfunc newObject(object_path string) *Object {\n\tzlib_bytes, err := os.ReadFile(object_path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\/\/ zlib expects an io.Reader object\n\treader, err := zlib.NewReader(bytes.NewReader(zlib_bytes))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tbytes, err := io.ReadAll(reader)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdata_ptr := &bytes\n\ttype_, first_space_index := getType(data_ptr)\n\tsize, content_start_index := getSize(first_space_index, data_ptr)\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\treturn &Object{type_, size, object_path, object_dir + filepath.Base(object_path), bytes[content_start_index:]}\n}\n\nfunc (obj *Object) toJson() string {\n\tswitch obj.type_ {\n\tcase \"tree\":\n\t\tentries := parseTree(obj)\n\t\toutput := \"[\\n\"\n\t\tfor i, entry := range entries {\n\t\t\tif i == len(entries)-1 {\n\t\t\t\toutput += entry.toJson() + \"\\n\"\n\t\t\t} else {\n\t\t\t\toutput += entry.toJson() + \",\\n\"\n\t\t\t}\n\t\t}\n\t\treturn output + \"]\\n\"\n\tcase \"commit\":\n\t\tcommit := parseCommit(obj)\n\t\tparents, _ := json.Marshal(commit.parents)\n\t\treturn fmt.Sprintf(`{\"parents\\\": %s, \"tree\": \"%s\"}`, string(parents), commit.tree)\n\tcase \"blob\":\n\t\treturn \"\\\"\" + strings.Replace(string(obj.content), `\"`, `\\\"`, -1) + \"\\\"\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"I'm a %s\\n\", obj.type_)\n\t}\n}\n\nfunc (e *TreeEntry) toJson() string {\n\treturn fmt.Sprintf(`{\"mode\": \"%s\", \"name\": \"%s\", \"hash\": \"%s\"}`, e.mode, e.name, e.hash)\n}\n\nfunc getObjectName(object_path string) string {\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\tname := object_dir + filepath.Base(object_path)\n\treturn name\n}\n\nfunc getObjects(objects_dir string) map[string]*Object {\n\tvar objects map[string]*Object\n\tobjects = make(map[string]*Object)\n\tfilepath.WalkDir(objects_dir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tis_hex, err := regexp.MatchString(\"^[a-fA-F0-9]+$\", filepath.Base(path))\n\t\tif !d.IsDir() && is_hex {\n\t\t\tobj := newObject(path)\n\t\t\tobjects[obj.name] = obj\n\t\t}\n\t\treturn nil\n\t})\n\treturn objects\n}\n\nfunc newRepo(location string) *Repo {\n\tobjects := getObjects(location + \"\/.git\/objects\")\n\treturn &Repo{location, objects}\n}\n\nfunc (r *Repo) getObject(name string) *Object {\n\treturn r.objects[name]\n}\n\nfunc (r *Repo) toSQLite(path string) {\n\tos.Remove(path)\n\n\tdb, err := sql.Open(\"sqlite3\", path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(`create table objects (name text, type text, object jsonb)`)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tstmt, err := db.Prepare(\"insert into objects(name, type, object) values(?, ?, ?)\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\n\tfor name, obj := range r.objects {\n\t\t_, err = stmt.Exec(name, obj.type_, obj.toJson())\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc (r *Repo) refresh() {\n\tobjects := getObjects(r.location)\n\tr.objects = objects\n}\n\nfunc (r *Repo) head() string {\n\tbytes, err := os.ReadFile(r.location + \"\/.git\/HEAD\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn strings.TrimSpace(strings.Split(string(bytes), \":\")[1])\n}\n\nfunc (r *Repo) branch() string {\n\thead := r.head()\n\treturn filepath.Base(head)\n}\n\nfunc (r *Repo) current_commit() *Object {\n\tbytes, err := os.ReadFile(r.location + \"\/.git\/\" + r.head())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn r.getObject(strings.TrimSpace(string(bytes)))\n}\n\nfunc parseTree(obj *Object) []TreeEntry {\n\tvar entries []TreeEntry\n\tentry_item, start, stop := 1, 0, 6\n\tmode, name, hash := \"\", \"\", \"\"\n\tfor stop <= len(obj.content) {\n\t\tswitch entry_item {\n\t\t\/\/ get the mode\n\t\tcase 1:\n\t\t\tmode = strings.TrimSpace(string(obj.content[start:stop]))\n\t\t\tentry_item += 1\n\t\t\tstart = stop\n\t\t\/\/ get the name (file or dir)\n\t\tcase 2:\n\t\t\ti := start\n\t\t\tfor obj.content[i] != NUL && i < len(obj.content)-1 {\n\t\t\t\ti += 1\n\t\t\t}\n\t\t\tname = strings.TrimSpace(string(obj.content[start:i]))\n\t\t\tentry_item += 1\n\t\t\tstart = i + 1\n\t\t\tstop = start + 20\n\t\t\/\/ get the hash (object name)\n\t\tcase 3:\n\t\t\thash = strings.TrimSpace(hex.EncodeToString(obj.content[start:stop]))\n\t\t\tentry_item = 1\n\t\t\tstart = stop\n\t\t\tstop = start + 6\n\t\t\tentries = append(entries, TreeEntry{mode, name, hash})\n\t\t}\n\t}\n\treturn entries\n}\n\nfunc parseCommit(obj *Object) Commit {\n\ttree_hash := string(obj.content[5:45])\n\trest_of_content := strings.Split(string(obj.content[46:]), \"\\n\")\n\tvar parents []string\n\tfor _, line := range rest_of_content {\n\t\tif line[:6] == \"parent\" {\n\t\t\tparents = append(parents, line[7:47])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn Commit{tree_hash, parents}\n}\n\nfunc main() {\n\tvar repo_path string\n\tvar db_path string\n\n\tapp := &cli.App{\n\t\tUseShortOptionHandling: true,\n\t\tCommands: []*cli.Command{\n\t\t\t{\n\t\t\t\tName:  \"to-sqlite\",\n\t\t\t\tUsage: \"dfsdf\",\n\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t&cli.StringFlag{\n\t\t\t\t\t\tName:        \"repo-path\",\n\t\t\t\t\t\tValue:       \".\",\n\t\t\t\t\t\tAliases:     []string{\"r\"},\n\t\t\t\t\t\tDestination: &repo_path,\n\t\t\t\t\t\tUsage:       \"Pass multiple greetings\",\n\t\t\t\t\t},\n\t\t\t\t\t&cli.StringFlag{\n\t\t\t\t\t\tName:        \"db-path\",\n\t\t\t\t\t\tValue:       \"git.sqlite\",\n\t\t\t\t\t\tAliases:     []string{\"d\"},\n\t\t\t\t\t\tDestination: &db_path,\n\t\t\t\t\t\tUsage:       \"Pass multiple greetings\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tAction: func(cCtx *cli.Context) error {\n\t\t\t\t\trepo := newRepo(repo_path)\n\t\t\t\t\tfmt.Println(\"Generating Git SQLite database...\")\n\t\t\t\t\trepo.toSQLite(db_path)\n\t\t\t\t\tfmt.Println(\"Done generating database.\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := app.Run(os.Args); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"
        ],
        [
            "c3d4b48e92403a3a09e0569ee5938d44b52816c4",
            "blob",
            "package main\n\nimport (\n\t\"bytes\"\n\t\"compress\/zlib\"\n\t\"encoding\/hex\"\n\t\"encoding\/json\"\n\t\"fmt\"\n\t\"io\/fs\"\n\t\"io\/ioutil\"\n\t\"path\/filepath\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nconst (\n\tSPACE byte = 32\n\tNUL   byte = 0\n)\n\ntype Object struct {\n\tobj_type string\n\tsize     string\n\tlocation string\n\tname     string\n\tcontent  []byte\n}\n\ntype TreeEntry struct {\n\tmode string\n\tname string\n\thash string\n}\n\ntype Commit struct {\n\ttree    string\n\tparents []string\n}\n\ntype Repo struct {\n\tlocation string\n\tobjects  map[string]*Object\n}\n\nfunc getType(data *[]byte) (string, int) {\n\tfirst_space_index := findFirstMatch(SPACE, 0, data)\n\tobj_type := string((*data)[0:first_space_index])\n\treturn strings.TrimSpace(obj_type), first_space_index\n}\n\n\/\/ second return value is the start of the object's content\nfunc getSize(first_space_index int, data *[]byte) (string, int) {\n\tfirst_nul_index := findFirstMatch(NUL, first_space_index+1, data)\n\tobj_size := string((*data)[first_space_index:first_nul_index])\n\treturn strings.TrimSpace(obj_size), first_nul_index + 1\n}\n\nfunc newObject(object_path string) *Object {\n\tzlib_bytes, err := ioutil.ReadFile(object_path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\/\/ zlib expects an io.Reader object\n\treader, err := zlib.NewReader(bytes.NewReader(zlib_bytes))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tbytes, err := ioutil.ReadAll(reader)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdata_ptr := &bytes\n\tobj_type, first_space_index := getType(data_ptr)\n\tsize, content_start_index := getSize(first_space_index, data_ptr)\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\treturn &Object{obj_type, size, object_path, object_dir + filepath.Base(object_path), bytes[content_start_index:]}\n}\n\nfunc (obj *Object) toJson() string {\n\tswitch obj.obj_type {\n\tcase \"tree\":\n\t\tentries := parseTree(obj)\n\t\toutput := \"[\\n\"\n\t\tfor i, entry := range entries {\n\t\t\tif i == len(entries)-1 {\n\t\t\t\toutput += entry.toJson() + \"\\n\"\n\t\t\t} else {\n\t\t\t\toutput += entry.toJson() + \",\\n\"\n\t\t\t}\n\t\t}\n\t\treturn output + \"]\\n\"\n\tcase \"commit\":\n\t\tcommit := parseCommit(obj)\n\t\tparents, _ := json.Marshal(commit.parents)\n\t\treturn fmt.Sprintf(\"{ \\\"parents\\\": %s, \\\"tree\\\": \\\"%s\\\"}\", string(parents), commit.tree)\n\tcase \"blob\":\n\t\treturn \"\\\"\" + string(obj.content) + \"\\\"\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"I'm a %s\\n\", obj.obj_type)\n\t}\n}\n\nfunc (e *TreeEntry) toJson() string {\n\treturn fmt.Sprintf(\"{\\\"mode\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\", \\\"hash\\\": \\\"%s\\\"}\", e.mode, e.name, e.hash)\n}\n\nfunc getObjectName(object_path string) string {\n\tobject_dir := filepath.Base(filepath.Dir(object_path))\n\tname := object_dir + filepath.Base(object_path)\n\treturn name\n}\n\nfunc getObjects(objects_dir string) map[string]*Object {\n\tvar objects map[string]*Object\n\tobjects = make(map[string]*Object)\n\tfilepath.WalkDir(objects_dir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tis_hex, err := regexp.MatchString(\"^[a-fA-F0-9]+$\", filepath.Base(path))\n\t\tif !d.IsDir() && is_hex {\n\t\t\tobj := newObject(path)\n\t\t\tobjects[obj.name] = obj\n\t\t}\n\t\treturn nil\n\t})\n\treturn objects\n}\n\nfunc newRepo(location string) *Repo {\n\tobjects := getObjects(location + \"\/.git\/objects\")\n\treturn &Repo{location, objects}\n}\n\nfunc (r *Repo) getObject(name string) *Object {\n\treturn r.objects[name]\n}\n\nfunc (r *Repo) refresh() {\n\tobjects := getObjects(r.location)\n\tr.objects = objects\n}\n\nfunc (r *Repo) head() string {\n\tbytes, err := ioutil.ReadFile(r.location + \"\/.git\/HEAD\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn strings.TrimSpace(strings.Split(string(bytes), \":\")[1])\n}\n\nfunc (r *Repo) branch() string {\n\thead := r.head()\n\treturn filepath.Base(head)\n}\n\nfunc (r *Repo) current_commit() *Object {\n\tbytes, err := ioutil.ReadFile(r.location + \"\/.git\/\" + r.head())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn r.getObject(strings.TrimSpace(string(bytes)))\n}\n\nfunc parseTree(obj *Object) []TreeEntry {\n\tvar entries []TreeEntry\n\tentry_item, start, stop := 1, 0, 6\n\tmode, name, hash := \"\", \"\", \"\"\n\tfor stop <= len(obj.content) {\n\t\tswitch entry_item {\n\t\t\/\/ get the mode\n\t\tcase 1:\n\t\t\tmode = strings.TrimSpace(string(obj.content[start:stop]))\n\t\t\tentry_item += 1\n\t\t\tstart = stop\n\t\t\/\/ get the name (file or dir)\n\t\tcase 2:\n\t\t\ti := start\n\t\t\tfor obj.content[i] != NUL && i < len(obj.content)-1 {\n\t\t\t\ti += 1\n\t\t\t}\n\t\t\tname = strings.TrimSpace(string(obj.content[start:i]))\n\t\t\tentry_item += 1\n\t\t\tstart = i + 1\n\t\t\tstop = start + 20\n\t\t\/\/ get the hash (object name)\n\t\tcase 3:\n\t\t\thash = strings.TrimSpace(hex.EncodeToString(obj.content[start:stop]))\n\t\t\tentry_item = 1\n\t\t\tstart = stop\n\t\t\tstop = start + 6\n\t\t\tentries = append(entries, TreeEntry{mode, name, hash})\n\t\t}\n\t}\n\treturn entries\n}\n\nfunc parseCommit(obj *Object) Commit {\n\ttree_hash := string(obj.content[5:45])\n\trest_of_content := strings.Split(string(obj.content[46:]), \"\\n\")\n\tvar parents []string\n\tfor _, line := range rest_of_content {\n\t\tif line[:6] == \"parent\" {\n\t\t\tparents = append(parents, line[7:47])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn Commit{tree_hash, parents}\n}\n\nfunc main() {\n\trepo := newRepo(\"\/Users\/joebob\/Desktop\/mkdocs-multirepo-plugin\")\n\tobj := repo.getObject(\"03b07c783a602e71e392006106e9c482e7f5bffd\")\n\tfmt.Println(obj.toJson())\n\t\/\/repo.refresh()\n\tfmt.Println(repo.head())\n\tfmt.Println(repo.branch())\n\tobj = repo.current_commit()\n\tfmt.Println(obj.toJson())\n}\n"
        ],
        [
            "ab98e5e9a8dfb48955cd8647ff578baa0f99f206",
            "tree",
            "[\n{\"mode\": \"100644\", \"name\": \".gitignore\", \"hash\": \"66fd13c903cac02eb9657cd53fb227823484401d\"},\n{\"mode\": \"100644\", \"name\": \"LICENSE\", \"hash\": \"9adcb40f927482119da665a20b8379ab8e161c8a\"},\n{\"mode\": \"100644\", \"name\": \"README.md\", \"hash\": \"5803288b25eb0cfc5fc8648645a43b767290dcdc\"},\n{\"mode\": \"100644\", \"name\": \"git.go\", \"hash\": \"4bf781d59924ed565b705ee3c8ca47d8326d168b\"}\n]\n"
        ],
        [
            "657e8422719f786d7768d7f6512c6b2ff42e4433",
            "tree",
            "[\n{\"mode\": \"100644\", \"name\": \".gitignore\", \"hash\": \"66fd13c903cac02eb9657cd53fb227823484401d\"},\n{\"mode\": \"100644\", \"name\": \"LICENSE\", \"hash\": \"9adcb40f927482119da665a20b8379ab8e161c8a\"},\n{\"mode\": \"100644\", \"name\": \"README.md\", \"hash\": \"5803288b25eb0cfc5fc8648645a43b767290dcdc\"}\n]\n"
        ],
        [
            "85e4bdc0c8c2e69ccb6101807abee1d1942515df",
            "tree",
            "[\n{\"mode\": \"100644\", \"name\": \".gitignore\", \"hash\": \"66fd13c903cac02eb9657cd53fb227823484401d\"},\n{\"mode\": \"100644\", \"name\": \"LICENSE\", \"hash\": \"9adcb40f927482119da665a20b8379ab8e161c8a\"},\n{\"mode\": \"100644\", \"name\": \"README.md\", \"hash\": \"5803288b25eb0cfc5fc8648645a43b767290dcdc\"},\n{\"mode\": \"100644\", \"name\": \"go.mod\", \"hash\": \"04cae2c8019c039782fac140c206e93ce0066cca\"},\n{\"mode\": \"100644\", \"name\": \"go.sum\", \"hash\": \"9459eac0626138eb2c9fb5ccc76ced79264f61c0\"},\n{\"mode\": \"100644\", \"name\": \"gogit.go\", \"hash\": \"8a05daf2002461da0a5898ccb0a4d7e464f678fc\"}\n]\n"
        ],
        [
            "9b62d000c5a39450d7d4791a9f0cc7e11cf8a6fe",
            "blob",
            "package main\n\n\/\/ Given a byte find the first byte in a data slice that equals the match_byte, returning the index.\n\/\/ If no match is found, returns -1\nfunc findFirstMatch(match_byte byte, start_index int, data *[]byte) int {\n\tfor i, this_byte := range (*data)[start_index:] {\n\t\tif this_byte == match_byte {\n\t\t\treturn start_index + i\n\t\t}\n\t}\n\treturn -1\n}\n"
        ]
    ]
}